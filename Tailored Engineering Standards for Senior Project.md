# 6.4.2 Stakeholder Needs and Requirements Definition process
## 1. Prepare for Stakeholder Needs and Requirements Definition
### a. Identify the stakeholders who have an interest in the software system throughout its lifecycle.
#### i. 
#### ii.
#### iii.
### b. Define the stakeholder needs and requirements definition strategy.
#### i. 
#### ii.
#### iii.
### c. Identify and plan for the necessary enabling systems or services needed to support stakeholder needs and requirements definition.
#### i. 
#### ii.
#### iii.
### d. Obtain or acquire access to the enabling systems or services to be used.
#### i. 
#### ii.
#### iii.
## 2. Define stakeholder needs.
### a. Define context of use within the concept of operations and the preliminary life cycle concepts.
#### i. 
#### ii.
#### iii.
### b. Identify stakeholder needs.
#### i. 
#### ii.
#### iii.
### c. Prioritize and down‐select needs.
#### i. 
#### ii.
#### iii.
### d. Define the stakeholder needs and rationale.
#### i. 
#### ii.
#### iii.
## 3. Develop the operational concept and other life cycle concepts. 
### a. Define a representative set of scenarios to identify the required capabilities that correspond to anticipated operational and other life cycle concepts.
#### i. 
#### ii.
#### iii.
### b. Identify the factors affecting interactions between users and the system.
#### i. Anticipated physical, mental, and learned capabilities of the users;
##### A. 
##### B.
##### C.
#### ii. Workplace, environment and facilities, including other equipment in the context of use;
##### A. 
##### B.
##### C.
#### iii. Normal, unusual, and emergency conditions; and
##### A. 
##### B.
##### C.
#### iv. Operator and user recruitment, training and culture.
##### A. 
##### B.
##### C.
## 4. Transform stakeholder needs into stakeholder requirements.
### a. Identify the constraints on a system solution.
#### i. 
#### ii.
#### iii.
### b. Identify the stakeholder requirements and functions that relate to critical quality characteristics, such as assurance, safety, security, environment, or health.
#### i. 
#### ii.
#### iii.
### c. Define stakeholder requirements, consistent with life cycle concepts, scenarios, interactions, constraints, and critical quality characteristics.
#### i. 
#### ii.
#### iii.
## 5. Analyze stakeholder requirements.
### a. Analyze the complete set of stakeholder requirements.
#### i. 
#### ii.
#### iii.
### b. Define critical performance measures that enable the assessment of technical achievement.
#### i. 
#### ii.
#### iii.
### c. Feed back the analyzed requirements to applicable stakeholders to validate that their needs and expectations have been adequately captured and expressed.
#### i. 
#### ii.
#### iii.
### d. Resolve stakeholder requirements issues.
#### i. 
#### ii.
#### iii.
## 6. Manage the stakeholder needs and requirements definition.
### a. Obtain explicit agreement with designated stakeholders on the stakeholder requirements.
#### i. 
#### ii.
#### iii.
### b. Maintain traceability of stakeholder needs and requirements.
#### i. 
#### ii.
#### iii.
### c. Provide key artifacts and information items that have been selected for baselines.
#### i. 
#### ii.
#### iii.

# 6.4.4 Architecture Definition process
## 1. Prepare for architecture definition.
### a. Review pertinent information and identify key drivers of the architecture.
#### i. 
#### ii.
#### iii.
### b. Identify stakeholder concerns.
#### i. 
#### ii.
#### iii.
### c. Define the Architecture Definition roadmap, approach, and strategy.
#### i. 
#### ii.
#### iii.
### d. Define architecture evaluation criteria based on stakeholder concerns and key requirements.
#### i. 
#### ii.
#### iii.
### e. Identify and plan for the necessary enabling systems or services needed to support the Architecture Definition process.
#### i. 
#### ii.
#### iii.
### f. Obtain or acquire access to the enabling systems or services to be used.
#### i. 
#### ii.
#### iii.
## 2. Develop architecture viewpoints.
### a. Select, adapt, or develop viewpoints and model kinds based on stakeholder concerns.
#### i. 
#### ii.
#### iii.
### b. Establish or identify potential architecture framework(s) to be used in developing models and views.
#### i. 
#### ii.
#### iii.
### c. Capture rationale for selection of framework(s), viewpoints and model kinds.
#### i. 
#### ii.
#### iii.
### d. Select or develop supporting modelling techniques and tools.
#### i. 
#### ii.
#### iii.
## 3. Develop models and views of candidate architectures.
### a. Define the software system context and boundaries in terms of interfaces and interactions with external entities.
#### i. 
#### ii.
#### iii.
### b. Identify architectural entities and relationships between entities that address key stakeholder concerns and critical software system requirements.
#### i. 
#### ii.
#### iii.
### c. Allocate concepts, properties, characteristics, behaviors, functions, or constraints that are significant to architecture decisions of the software system to architectural entities.
#### i. 
#### ii.
#### iii.
### d. Select, adapt, or develop models of the candidate architectures of the software system.
#### i. 
#### ii.
#### iii.
### e. Compose views from the models in accordance with identified viewpoints to express how the architecture addresses stakeholder concerns and meets stakeholder and system/software requirements.
#### i. 
#### ii.
#### iii.
### f. Harmonize the architecture models and views with each other.
#### i. 
#### ii.
#### iii.
## 4. Relate the architecture to design.
### a. Identify software system elements that relate to architectural entities and the nature of these relationships.
#### i. f
#### ii.
#### iii.
### b. Define the interfaces and interactions among the software system elements and external entities.
#### i. e
#### ii. This is not XP compliant, as these definitions are constantly changing and only defining them once during the project's lifespan will be detrimental.
#### iii.
### c. Partition, align and allocate requirements to architectural entities and system elements.
#### i. c
#### ii.
#### iii.
### d. Map software system elements and architectural entities to design characteristics.
#### i. e
#### ii.
#### iii.
### e. Define principles for the software system design and evolution.
#### i. b
#### ii. This is not XP compliant, as principles and other requirements for a project are constantly changing and should not be treated as static guidelines.
#### iii. We use existing software and research papers in order to see which principles we needed to take into consideration.
## 5. Assess architecture candidates.
### a. Assess each candidate architecture against constraints and requirements.
#### i. g
#### ii.
#### iii.
### b. Assess each candidate architecture against stakeholder concerns using evaluation criteria.
#### i. g
#### ii. This is not XP compliant, as there should be only one candidate architecture to consider in the first place using the evaluation criteria.
#### iii.
### c. Select the preferred architecture(s) and capture key decisions and rationale.
#### i. h
#### ii. This is not XP compliant, there should only be one architecture for the project, not several.
#### iii.
### d. Establish the architecture baseline of the selected architecture.
#### i. d
#### ii. 
#### iii.
## 6. Assess architecture candidates.
### a. Formalize the architecture governance approach and specify governance‐related roles and responsibilities, accountabilities, and authorities related to design, quality, security, and safety.
#### i. d
#### ii.
#### iii.
### b. Obtain explicit acceptance of the architecture by stakeholders.
#### i. i
#### ii. XP says to obtain acceptance by allowing stakeholders to be active in developing the architecture. "Generally, the closer customer needs and development capabilities are, the more valuable development becomes." (Chapter 9, real customer development)
#### iii. We demonstrate our current solutions to the client in weekly meetings so they can provide feedback.
### c. Maintain concordance and completeness of the architectural entities and their architectural characteristics.
#### i. h
#### ii.
#### iii.
### d. Organize, assess and control evolution of the architecture models and views to help ensure that the architectural intent is met and the architectural vision and key concepts are correctly implemented.
#### i. e
#### ii.
#### iii.
### e. Maintain the architecture definition and evaluation strategy.
#### i. b
#### ii.
#### iii.
### f. Maintain traceability of the architecture.
#### i. k
#### ii.
#### iii.
### g. Provide key artifacts and information items that have been selected for baselines.
#### i. j
#### ii. This is not XP compliant, as any artifacts and documentation must be generated from the code itself.
#### iii.

# 6.4.5 Design Definition process

## 1. Prepare for software system design definition.

### a. Define the design definition strategy, consistent with the selected life cycle model and anticipated design artifacts.
#### i. c
#### ii. XP defines the design strategy as incremental design with quarterly cycles to review. There are no anticipated design artifacts because XP states to "maintain only the code and the tests as permanent artifacts."
#### iii. We use XP's practice here. For example, after each weekly client meeting, we plan for the design and work of the next week.

### b. Select and prioritize design principles and design characteristics.
#### i. a
#### ii. XP states to "have the customers pick a week's worth of stories" every week, deferring the selection and prioritization to them.
#### iii. We select tasks weekly and discuss their priority with our client.

### c. Identify and plan for the necessary enabling systems or services needed to support design definition.
#### i. c
#### ii. XP doesn't mention enabling systems. However, in the case that you can't design without access to some design-enabling system, XP suggests to work on what you can by "[striving] to make the design of the system an excellent fit for the needs of the system that day." Do what you can, and then fix the rest once you get access.
#### iii. We haven't had any need for design definition-enabling systems yet.

### d. Obtain or acquire access to the enabling systems or services to be used.
#### i. g
#### ii. XP doesn't mention enabling systems. However, XP does suggest to "include on the team people with all the skills and perspectives necessary for the team to succeed," so you might be able to ask a team member for access.
#### iii. We haven't had any need for design definition-enabling systems yet.

## 2. Establish designs related to each software system element.

### a. Transform architectural and design characteristics into the design of software system elements.
#### i. a
#### ii. XP states to "make the design of the system an excellent fit for the needs of the system that day," so the design is automatically based on architectural and requirement constraints.
#### iii. Due to the nature of our project, we automatically consider architectural requirements while we design. For example, the design of the plugin is highly dependent on the architectures we support, since they control how we access the needed data.

### b. Define and prepare or obtain the necessary design enablers.
#### i. g
#### ii. XP doesn't mention design enablers. However, XP states to "make the design of the system an excellent fit for the needs of the system that day," so you should obtain the necessary design enablers as needed on the day of.
#### iii. We obtain required dependencies as part of our tasks. For example, we only downloaded our busybox dependency once we actually needed to use it.

### c. Examine design alternatives and feasibility of implementation.
#### i. e
#### ii. XP states to "make the design of the system an excellent fit for the needs of the system that day," so there shouldn't be any design alternatives-- simply designs.
#### iii. Because our system is highly dependent on the client's domain-specific knowledge, when attempted approaches don't pan out, we bring a number of options and their feasibilities to the client for discussion.

### d. Refine or define the interfaces among the software system elements and with external entities.
#### i. d
#### ii. XP states to "make the design of the system an excellent fit for the needs of the system that day" and to "identify bottlenecks, especially those controlled outside the team" quarterly. So, interfaces should be designed and refined as needed day-to-day, and if they're posing a problem, repaired at the end of a quarter.
#### iii. In order to facilitate the distribution of tasks, we split our system into components early into the project. The interface with external entities, however, is refined daily.

### e. Establish the design artifacts.
#### i. f
#### ii. N/A. XP states to "maintain only the code and the tests as permanent artifacts," so design artifacts are incompatible with XP.
#### iii. We don't have any design artifacts.

## 3. Assess alternatives for obtaining software system elements.

### a. Determine technologies required for each element composing the software system.
#### i. b
#### ii. XP designs incrementally, determining required technologies as needed, planning to "initiate repairs" as needed during quarterly meetings. 
#### iii. We do this during our weekly meetings with the client, to make use of their domain-specific knowledge and preferences. For example, we determined the need for fakeroot when discussing the usermode component with the client.

### b. Identify candidate alternatives for the software system elements.
#### i. e
#### ii. XP states to "invest in the design of the system every day" to make it an "excellent fit for the needs of the system that day," so you should identify candidate alternatives only as necessary.
#### iii. We similarly discuss these when determining required technologies. Following the same example as above, cpio and dimitri were discussed alternatives.

### c. Assess each candidate alternative against criteria developed from expected design characteristics and element requirements to determine suitability for the intended application.
#### i. e
#### ii. XP doesn't say much to this regard. Design options must obviously be assessed for viability, all XP has to say is that you should defer these decisions to the "last responsible moment."
#### iii. We have limited time during our client meetings, so we assess listed options during worktime via research and trial-and-error. For example, in order to find the tasklist, we researched and attempted several approaches (stack, fs/gs, symtab) in order to assess their viability.

### d. Choose the preferred alternatives among candidate design solutions for the software system elements.
#### i. e
#### ii. XP attempts to defer design to the "last responsible moment," and to "fit the needs of the system that day." Thus, XP simply chooses the easiest alternative that currently works, and will re-evaluate later if necessary.
#### iii. Because XP practices the use of the simplest possible working product, we just go with the first viable alternative. For example, parsing instructions from memory is a viable option, but it's significantly more complex than the stack option.

## 4. Manage the design.

### a. Capture the design and rationale.
#### i. f
#### ii. N/A. XP states to "maintain only the code and the tests as permanent artifacts," so design artifacts are incompatible with XP.
#### iii. Because design artifacts are incompatible with XP, we don't practice this task. We do, however, discuss our design and rationale with our client weekly.

### b. Establish traceability between the detailed design elements, the system/software requirements, and the architectural entities of the software system architecture.
#### i. h
#### ii. N/A. XP states to "maintain only the code and the tests as permanent artifacts," so design artifacts are incompatible with XP. XP also disagrees with requirements, preferring stories over them because "they [aren't] really mandatory or obligatory".
#### iii. We don't maintain traceability design artifacts. However, we do practice incremental design, so you can use git history to trace changes to tasks.

### c. Determine the status of the software system and element design.
#### i. f
#### ii. XP recommends weekly meetings where you "review progress to date," and that you should "invest in the design of the system every day." XP also recommends quarterly meetings to "identify bottlenecks" and thus check in on the system's overall status. In short, XP says to determine the status of the system quarterly and the status of the element design weekly.
#### iii. We check in on design status weekly, such as in our client meetings and during our task-estimation meetings. We also review the status of our system weekly with the client and adivsor.

### d. Provide key artifacts and information items that have been selected for baselines.
#### i. f
#### ii. N/A. XP states to "maintain only the code and the tests as permanent artifacts," so design artifacts are incompatible with XP.
#### iii. Because design artifacts are incompatible with XP, we don't practice this task.