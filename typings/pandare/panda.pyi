from .arch import Aarch64Arch as Aarch64Arch, ArmArch as ArmArch, Mips64Arch as Mips64Arch, MipsArch as MipsArch, PowerPCArch as PowerPCArch, X86Arch as X86Arch, X86_64Arch as X86_64Arch
from .asyncthread import AsyncThread as AsyncThread
from .cosi import Cosi as Cosi
from .panda_expect import Expect as Expect
from .qcows_internal import Qcows as Qcows
from .qemu_logging import QEMU_Log_Manager as QEMU_Log_Manager
from .taint import TaintQuery as TaintQuery
from .utils import GArrayIterator as GArrayIterator, blocking as blocking, debug as debug, find_build_dir as find_build_dir, make_iso as make_iso, plugin_list as plugin_list, progress as progress, rr2_contains_member as rr2_contains_member, rr2_recording as rr2_recording, warn as warn
from _typeshed import Incomplete
from cffi import FFI as FFI
from os import getenv as getenv
from os.path import abspath as abspath, dirname as dirname
from random import randint as randint
from collections.abc import Callable

class Panda:
    arch_name: Incomplete
    mem: Incomplete
    os: Incomplete
    os_type: Incomplete
    qcow: Incomplete
    plugins: Incomplete
    expect_prompt: Incomplete
    lambda_cnt: int
    ending: bool
    cdrom: Incomplete
    catch_exceptions: Incomplete
    qlog: Incomplete
    build_dir: Incomplete
    plugin_path: Incomplete
    serial_unconsumed_data: bytes
    arch: Incomplete
    libpanda_path: Incomplete
    panda: Incomplete
    ffi: Incomplete
    libpanda: Incomplete
    C: Incomplete
    panda_args: Incomplete
    serial_file: Incomplete
    serial_socket: Incomplete
    serial_console: Incomplete
    monitor_file: Incomplete
    monitor_socket: Incomplete
    raw_monitor: Incomplete
    monitor_console: Incomplete
    running: Incomplete
    started: Incomplete
    initializing: Incomplete
    athread: Incomplete
    plugin_register_count: int
    registered_callbacks: Incomplete
    disabled_tb_chaining: bool
    named_hooks: Incomplete
    hook_list: Incomplete
    hook_list2: Incomplete
    mem_hooks: Incomplete
    sr_hooks: Incomplete
    hypercalls: Incomplete
    current_asid_name: Incomplete
    asid_mapping: Incomplete
    exception: Incomplete
    cosi: Incomplete
    main_loop_wait_fnargs: Incomplete
    def __init__(self, arch: str = 'i386', mem: str = '128M', expect_prompt: Incomplete | None = None, serial_kwargs: Incomplete | None = None, os_version: Incomplete | None = None, qcow: Incomplete | None = None, os: str = 'linux', generic: Incomplete | None = None, raw_monitor: bool = False, extra_args: Incomplete | None = None, catch_exceptions: bool = True, libpanda_path: Incomplete | None = None, biospath: Incomplete | None = None, plugin_path: Incomplete | None = None) -> None: ...
    def get_plugin_path(self): ...
    def get_build_dir(self): ...
    def queue_main_loop_wait_fn(self, fn, args=[]) -> None: ...
    def exit_cpu_loop(self) -> None: ...
    warned_async: bool
    def revert_async(self, snapshot_name) -> None: ...
    def reset(self) -> None: ...
    def cont(self) -> None: ...
    def vm_stop(self, code: int = 4) -> None: ...
    def snap(self, snapshot_name) -> None: ...
    def delvm(self, snapshot_name) -> None: ...
    def enable_tb_chaining(self) -> None: ...
    def disable_tb_chaining(self) -> None: ...
    def run(self) -> None: ...
    def end_analysis(self) -> None: ...
    def record(self, recording_name, snapshot_name: Incomplete | None = None) -> None: ...
    def end_record(self) -> None: ...
    def recording_exists(self, name): ...
    def run_replay(self, replaypfx) -> None: ...
    def end_replay(self) -> None: ...
    def require(self, name) -> None: ...
    def load_plugin(self, name, args={}) -> None: ...
    def unload_plugin(self, name) -> None: ...
    def unload_plugins(self) -> None: ...
    def memsavep(self, file_out) -> None: ...
    def physical_memory_read(self, addr, length, fmt: str = 'bytearray'): ...
    def virtual_memory_read(self, cpu, addr, length, fmt: str = 'bytearray'): ...
    def physical_memory_write(self, addr, buf) -> None: ...
    def virtual_memory_write(self, cpu, addr, buf) -> None: ...
    def callstack_callers(self, lim, cpu): ...
    exit_exception: Incomplete
    def queue_async(self, f, internal: bool = False) -> None: ...
    def map_memory(self, name, size, address): ...
    def read_str(self, cpu, ptr, max_length: Incomplete | None = None): ...
    def to_unsigned_guest(self, x): ...
    def from_unsigned_guest(self, x, bits: Incomplete | None = None): ...
    def queue_blocking(self, func, queue: bool = True): ...
    @property
    def pyplugins(self): ...
    def set_pandalog(self, name) -> None: ...
    def enable_memcb(self) -> None: ...
    def disable_memcb(self) -> None: ...
    def virt_to_phys(self, cpu, addr): ...
    def enable_plugin(self, handle) -> None: ...
    def disable_plugin(self, handle) -> None: ...
    def enable_llvm(self) -> None: ...
    def disable_llvm(self) -> None: ...
    def enable_llvm_helpers(self) -> None: ...
    def disable_llvm_helpers(self) -> None: ...
    def flush_tb(self): ...
    def break_exec(self): ...
    def enable_precise_pc(self) -> None: ...
    def disable_precise_pc(self) -> None: ...
    def in_kernel(self, cpustate): ...
    def in_kernel_mode(self, cpustate): ...
    def in_kernel_code_linux(self, cpustate): ...
    def g_malloc0(self, size): ...
    def current_sp(self, cpu): ...
    def current_pc(self, cpu): ...
    def current_asid(self, cpu): ...
    def get_id(self, cpu): ...
    def disas2(self, code, size) -> None: ...
    def cleanup(self) -> None: ...
    def was_aborted(self): ...
    def get_cpu(self): ...
    def garray_len(self, garray): ...
    def panda_finish(self): ...
    def rr_get_guest_instr_count(self): ...
    def drive_get(self, blocktype, bus, unit): ...
    def sysbus_create_varargs(self, name, addr): ...
    def cpu_class_by_name(self, name, cpu_model): ...
    def object_class_by_name(self, name): ...
    def object_property_set_bool(self, obj, value, name): ...
    def object_class_get_name(self, objclass): ...
    def object_new(self, name): ...
    def object_property_get_bool(self, obj, name): ...
    def object_property_set_int(self, obj, value, name): ...
    def object_property_get_int(self, obj, name): ...
    def object_property_set_link(self, obj, val, name): ...
    def object_property_get_link(self, obj, name): ...
    def object_property_find(self, obj, name): ...
    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size): ...
    def memory_region_add_subregion(self, mr, offset, sr): ...
    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path): ...
    def create_internal_gic(self, vbi, irqs, gic_vers): ...
    def create_one_flash(self, name, flashbase, flashsize, filename, mr): ...
    def create_external_gic(self, vbi, irqs, gic_vers, secure): ...
    def create_virtio_devices(self, vbi, pic): ...
    def arm_load_kernel(self, cpu, bootinfo): ...
    def error_report(self, s): ...
    def get_system_memory(self): ...
    def lookup_gic(self, n): ...
    def set_os_name(self, os_name) -> None: ...
    def get_os_family(self): ...
    def get_file_name(self, cpu, fd): ...
    def get_current_process(self, cpu): ...
    def get_mappings(self, cpu): ...
    def get_mapping_by_addr(self, cpu, addr): ...
    def get_processes(self, cpu): ...
    def get_processes_dict(self, cpu): ...
    def get_process_name(self, cpu): ...
    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr): ...
    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val): ...
    pyperipherals: Incomplete
    pyperipherals_registered_cb: bool
    def register_pyperipheral(self, object) -> None: ...
    def unregister_pyperipheral(self, pyperiph): ...
    def taint_enabled(self): ...
    def taint_enable(self) -> None: ...
    def taint_label_reg(self, reg_num, label) -> None: ...
    def taint_label_ram(self, addr, label) -> None: ...
    def taint_check_reg(self, reg_num): ...
    def taint_check_ram(self, addr): ...
    def taint_get_reg(self, reg_num): ...
    def taint_get_ram(self, addr): ...
    def taint_check_laddr(self, addr, off): ...
    def taint_get_laddr(self, addr, offset): ...
    def address_to_ram_offset(self, hwaddr, is_write): ...
    def taint_sym_enable(self) -> None: ...
    def taint_sym_label_ram(self, addr, label) -> None: ...
    def taint_sym_label_reg(self, reg_num, label) -> None: ...
    def string_to_solver(self, string: str): ...
    def string_to_condition(self, string: str): ...
    def string_to_expr(self, string: str): ...
    def taint_sym_query_ram(self, addr, size: int = 1): ...
    def taint_sym_query_reg(self, addr): ...
    def taint_sym_path_constraints(self): ...
    def taint_sym_branch_meta(self): ...
    pos: int
    length: Incomplete
    closed: bool
    mode: str
    name: str
    classname: Incomplete
    def make_panda_file_handler(self, debug: bool = False): ...
    def get_volatility_symbols(self, debug: bool = False): ...
    def run_volatility(self, plugin, debug: bool = False): ...
    def stop_run(self) -> None: ...
    def run_serial_cmd(self, cmd, no_timeout: bool = False, timeout: Incomplete | None = None): ...
    def serial_read_until(self, byte_sequence): ...
    def run_serial_cmd_async(self, cmd, delay: int = 1) -> None: ...
    def type_serial_cmd(self, cmd) -> None: ...
    def finish_serial_cmd(self): ...
    def run_monitor_cmd(self, cmd): ...
    def revert_sync(self, snapshot_name): ...
    def delvm_sync(self, snapshot_name) -> None: ...
    def copy_to_guest(self, copy_directory, iso_name: Incomplete | None = None, absolute_paths: bool = False, setup_script: str = 'setup.sh', timeout: Incomplete | None = None, cdrom: Incomplete | None = None) -> None: ...
    def record_cmd(self, guest_command, copy_directory: Incomplete | None = None, iso_name: Incomplete | None = None, setup_command: Incomplete | None = None, recording_name: str = 'recording', snap_name: str = 'root', ignore_errors: bool = False) -> None: ...
    def interact(self, confirm_quit: bool = True) -> None: ...
    def do_panda_finish(self) -> None: ...
    def register_cb_decorators(self): ...
    def register_callback(self, callback, function, name, enabled: bool = True, procname: Incomplete | None = None) -> None: ...
    def is_callback_enabled(self, name): ...
    def enable_internal_callbacks(self) -> None: ...
    def enable_all_callbacks(self) -> None: ...
    def enable_callback(self, name) -> None: ...
    def disable_callback(self, name, forever: bool = False) -> None: ...
    old_cb_list: Incomplete
    def delete_callback(self, name) -> None: ...
    def delete_callbacks(self) -> None: ...
    ppp_registered_cbs: Incomplete
    def ppp(self, plugin_name: str, attr: str, name: str | None = None, autoload: bool = True) -> Callable[[Callable], Callable]: ...
    def disable_ppp(self, name) -> None: ...
    def set_breakpoint(self, cpu, pc) -> None: ...
    def clear_breakpoint(self, cpu, pc) -> None: ...
    def hook(self, addr, enabled: bool = True, kernel: Incomplete | None = None, asid: Incomplete | None = None, cb_type: str = 'start_block_exec'): ...
    def hook_symbol_resolution(self, libraryname, symbol, name: Incomplete | None = None): ...
    def hook_symbol(self, libraryname, symbol, kernel: bool = False, name: Incomplete | None = None, cb_type: str = 'start_block_exec'): ...
    def get_best_matching_symbol(self, cpu, pc: Incomplete | None = None, asid: Incomplete | None = None): ...
    def enable_hook2(self, hook_name) -> None: ...
    def disable_hook2(self, hook_name) -> None: ...
    hook_gc_list: Incomplete
    def hook2(self, name, kernel: bool = True, procname: Incomplete | None = None, libname: Incomplete | None = None, trace_start: int = 0, trace_stop: int = 0, range_begin: int = 0, range_end: int = 0): ...
    def hook2_single_insn(self, name, pc, kernel: bool = False, procname: Incomplete | None = None, libname: Incomplete | None = None): ...
    def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled): ...
    def hook_phys_mem_read(self, start_address, end_address, on_before: bool = True, on_after: bool = False, enabled: bool = True): ...
    def hook_phys_mem_write(self, start_address, end_address, on_before: bool = True, on_after: bool = False): ...
    def hook_virt_mem_read(self, start_address, end_address, on_before: bool = True, on_after: bool = False): ...
    def hook_virt_mem_write(self, start_address, end_address, on_before: bool = True, on_after: bool = False): ...
    def hypercall(self, magic): ...
    def disable_hypercall(self, fn) -> None: ...
    def cb_guest_hypercall(self, fn): ...
    def cb_start_block_exec(self, fn): ...
