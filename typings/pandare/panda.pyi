from .arch import Aarch64Arch as Aarch64Arch, ArmArch as ArmArch, Mips64Arch as Mips64Arch, MipsArch as MipsArch, PowerPCArch as PowerPCArch, X86Arch as X86Arch, X86_64Arch as X86_64Arch
from .asyncthread import AsyncThread as AsyncThread
from .cosi import Cosi as Cosi
from .panda_expect import Expect as Expect
from .qemu_logging import QEMU_Log_Manager as QEMU_Log_Manager
from .taint import TaintQuery as TaintQuery
from .utils import GArrayIterator as GArrayIterator, blocking as blocking, debug as debug, plugin_list as plugin_list, rr2_contains_member as rr2_contains_member, rr2_recording as rr2_recording
from _typeshed import Incomplete
from cffi import FFI as FFI
from os import getenv as getenv
from os.path import abspath as abspath, dirname as dirname
from random import randint as randint
from collections.abc import Callable
from typing import Protocol, Literal
from exert.utilities.types.multi_arch import CPUState

class PPPFunction(Protocol):
    def __call__(self, *args, **kwargs): ...

class Panda:
    arch_name: Incomplete
    mem: Incomplete
    os: Incomplete
    os_type: Incomplete
    qcow: Incomplete
    plugins: Incomplete
    expect_prompt: Incomplete
    lambda_cnt: int
    ending: bool
    cdrom: Incomplete
    catch_exceptions: Incomplete
    qlog: Incomplete
    build_dir: Incomplete
    plugin_path: Incomplete
    serial_unconsumed_data: bytes
    arch: Incomplete
    libpanda_path: Incomplete
    panda: Incomplete
    ffi: Incomplete
    libpanda: Incomplete
    C: Incomplete
    panda_args: Incomplete
    serial_file: Incomplete
    serial_socket: Incomplete
    serial_console: Incomplete
    monitor_file: Incomplete
    monitor_socket: Incomplete
    raw_monitor: Incomplete
    monitor_console: Incomplete
    running: Incomplete
    started: Incomplete
    initializing: Incomplete
    athread: Incomplete
    plugin_register_count: int
    registered_callbacks: Incomplete
    disabled_tb_chaining: bool
    named_hooks: Incomplete
    hook_list: Incomplete
    hook_list2: Incomplete
    mem_hooks: Incomplete
    sr_hooks: Incomplete
    hypercalls: Incomplete
    current_asid_name: Incomplete
    asid_mapping: Incomplete
    exception: Incomplete
    cosi: Incomplete
    main_loop_wait_fnargs: Incomplete
    def __init__(self, arch: str = 'i386', mem: str = '128M', expect_prompt: Incomplete | None = None, serial_kwargs: Incomplete | None = None, os_version: Incomplete | None = None, qcow: Incomplete | None = None, os: str = 'linux', generic: Incomplete | None = None, raw_monitor: bool = False, extra_args: Incomplete | None = None, catch_exceptions: bool = True, libpanda_path: Incomplete | None = None, biospath: Incomplete | None = None, plugin_path: Incomplete | None = None) -> None: ...
    def get_plugin_path(self): ...
    def get_build_dir(self): ...
    def exit_cpu_loop(self) -> None: ...
    warned_async: bool
    def reset(self) -> None: ...
    def cont(self) -> None: ...
    def vm_stop(self, code: int = 4) -> None: ...
    def enable_tb_chaining(self) -> None: ...
    def disable_tb_chaining(self) -> None: ...
    def run(self) -> None: ...
    def end_analysis(self) -> None: ...
    def end_record(self) -> None: ...
    def recording_exists(self, name): ...
    def end_replay(self) -> None: ...
    def unload_plugins(self) -> None: ...
    def virtual_memory_read(self, cpu: CPUState, addr: int, length: int, fmt: str = 'bytearray') -> (bytes | int | str | list[int]): ...
    def callstack_callers(self, lim, cpu): ...
    exit_exception: Incomplete
    def map_memory(self, name, size, address): ...
    def read_str(self, cpu: CPUState, ptr: int, max_length: int | None = None) -> str: ...
    def to_unsigned_guest(self, x): ...
    def queue_blocking(self, func: Callable[[], None], queue: bool = True) -> Callable[[], None]: ...
    @property
    def pyplugins(self): ...
    def enable_memcb(self) -> None: ...
    def disable_memcb(self) -> None: ...
    def virt_to_phys(self, cpu, addr): ...
    def enable_llvm(self) -> None: ...
    def disable_llvm(self) -> None: ...
    def enable_llvm_helpers(self) -> None: ...
    def disable_llvm_helpers(self) -> None: ...
    def flush_tb(self): ...
    def break_exec(self): ...
    def enable_precise_pc(self) -> None: ...
    def disable_precise_pc(self) -> None: ...
    def in_kernel(self, cpustate: CPUState) -> bool: ...
    def in_kernel_mode(self, cpustate: CPUState) -> bool: ...
    def in_kernel_code_linux(self, cpustate): ...
    def g_malloc0(self, size): ...
    def current_sp(self, cpu: CPUState) -> int: ...
    def current_pc(self, cpu): ...
    def current_asid(self, cpu): ...
    def get_id(self, cpu): ...
    def cleanup(self) -> None: ...
    def was_aborted(self): ...
    def get_cpu(self) -> CPUState: ...
    def garray_len(self, garray): ...
    def panda_finish(self): ...
    def rr_get_guest_instr_count(self): ...
    def drive_get(self, blocktype, bus, unit): ...
    def sysbus_create_varargs(self, name, addr): ...
    def cpu_class_by_name(self, name, cpu_model): ...
    def object_class_by_name(self, name): ...
    def object_property_set_bool(self, obj, value, name): ...
    def object_class_get_name(self, objclass): ...
    def object_new(self, name): ...
    def object_property_get_bool(self, obj, name): ...
    def object_property_set_int(self, obj, value, name): ...
    def object_property_get_int(self, obj, name): ...
    def object_property_set_link(self, obj, val, name): ...
    def object_property_get_link(self, obj, name): ...
    def object_property_find(self, obj, name): ...
    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size): ...
    def memory_region_add_subregion(self, mr, offset, sr): ...
    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path): ...
    def create_internal_gic(self, vbi, irqs, gic_vers): ...
    def create_one_flash(self, name, flashbase, flashsize, filename, mr): ...
    def create_external_gic(self, vbi, irqs, gic_vers, secure): ...
    def create_virtio_devices(self, vbi, pic): ...
    def arm_load_kernel(self, cpu, bootinfo): ...
    def error_report(self, s): ...
    def get_system_memory(self): ...
    def lookup_gic(self, n): ...
    def get_os_family(self): ...
    def get_file_name(self, cpu, fd): ...
    def get_current_process(self, cpu): ...
    def get_mappings(self, cpu): ...
    def get_mapping_by_addr(self, cpu, addr): ...
    def get_processes(self, cpu): ...
    def get_processes_dict(self, cpu): ...
    def get_process_name(self, cpu): ...
    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr): ...
    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val): ...
    pyperipherals: Incomplete
    pyperipherals_registered_cb: bool
    def unregister_pyperipheral(self, pyperiph): ...
    def taint_enabled(self): ...
    def taint_enable(self) -> None: ...
    def taint_check_reg(self, reg_num): ...
    def taint_check_ram(self, addr): ...
    def taint_get_reg(self, reg_num): ...
    def taint_get_ram(self, addr): ...
    def taint_check_laddr(self, addr, off): ...
    def taint_get_laddr(self, addr, offset): ...
    def address_to_ram_offset(self, hwaddr, is_write): ...
    def taint_sym_enable(self) -> None: ...
    def taint_sym_query_reg(self, addr): ...
    def taint_sym_path_constraints(self): ...
    def taint_sym_branch_meta(self): ...
    pos: int
    length: Incomplete
    closed: bool
    mode: str
    name: str
    classname: Incomplete
    def stop_run(self) -> None: ...
    def run_serial_cmd(self, cmd: str, no_timeout: bool = False, timeout: int | None = None) -> str: ...
    def serial_read_until(self, byte_sequence): ...
    def finish_serial_cmd(self): ...
    def run_monitor_cmd(self, cmd): ...
    def revert_sync(self, snapshot_name: str) -> str: ...
    def interact(self, confirm_quit: bool = True) -> None: ...
    def do_panda_finish(self) -> None: ...
    def register_cb_decorators(self): ...
    def is_callback_enabled(self, name): ...
    def enable_internal_callbacks(self) -> None: ...
    def enable_all_callbacks(self) -> None: ...
    def enable_callback(self, name: str) -> None: ...
    def disable_callback(self, name: str, forever: bool = False) -> None: ...
    old_cb_list: Incomplete
    def delete_callbacks(self) -> None: ...
    ppp_registered_cbs: Incomplete
    def ppp(self, plugin_name: str, attr: str, name: str | None = None, autoload: bool = True) -> Callable[[PPPFunction], PPPFunction]: ...
    hook_gc_list: Incomplete
    def hypercall(self, magic): ...
    def cb_guest_hypercall(self, fn): ...
    def cb_start_block_exec(self, fn): ...
    endianness: Literal["little", "big"]
    bits: int
